#!/usr/bin/env bash
# Patche. Version 5.

# Needs at least as much disk space as the biggest file in the directory.

PATCHEVERSION="5"

#Script should run as root.
#Uncomment the next line and the eof for final version.
#exec sudo -s /bin/bash - << eof

#Exit if a command returns a nonzero value.
set -e;

#Set up logging
NOW="$(date '+%Y.%m.%d-%H.%M.%S.%z')"
echo "Setting up logging..."
mkdir -p -v "./.patche-repo/logs"
outfile="./.patche-repo/logs/$NOW.log"

#UUID creator
newuuid() {
	NEWUUID=$(python -c 'import uuid; print str(uuid.uuid4())')
}

#Main function body
patche() {
	echo "Started Patche at $NOW."
	if [ "$1" = "patch" ]; then
		if [ "$2" != "" ]; then
			mkdir -v "./.patche-repo-temp"
			if [ -d "./.patche-repo" ]; then
				echo "Repository needs updating. Removing previous repository data"
				mv -v "./.patche-repo/config/.pbz" "./.patche-repo-temp/.pbz"
				rm -rv "./.patche-repo"
			else
				if [ "$3" != "" ]; then
					echo -n "$3" > "./.patche-repo-temp/.pbz"
				else
					echo "You did not provide a passphrase, or the passphrase was empty. Please provide a non-empty passphrase as the third argument to the patche command."
					echo "Aborting."
					exit 1
				fi
			fi
			echo "Downloading new repository data"
			wget -O "./.patche-repo-temp/seed.pax.xz.gpg" "$2"
			gpg --yes --batch --passphrase-file "./.patche-repo-temp/.pbz" "./.patche-repo-temp/seed.pax.xz.gpg"
			rm -v "./.patche-repo-temp/seed.pax.xz.gpg"
			unxz -v "./.patche-repo-temp/seed.pax.xz"
			rm -v "./.patche-repo-temp/seed.pax.xz"
			tar -x -v "./.patche-repo-temp/seed.pax"
			rm -v "./.patche-repo-temp/seed.pax"
			echo "Done extracting downloaded seed record; now patching payload into repository."
			
			#Move all files in current directory to their sha512s
			mkdir -v "./.patche-repo-temp/record-data-by-hash"
			patchemover() {
				#Record mover
				SHA=$("shasum -a 512 \"$1\"")
				mv -fv "$1" "./.patche-repo-temp/record-data-by-hash/$SHA"
			}
			export -f patchemover
			find . -type f ! -path "./.patche-repo-temp/*" ! -path "./.patche-repo/*" -exec bash -c 'patchemover "$0"' {} \;

			#Remove remaining stuff in current directory
			find . ! -path "./.patche-repo-temp/*" ! -path "./.patche-repo/*" -exec rm -rfv {} \;

			#Rsync snapshot directory to current director
			THISREVISION="$(cat ./.patche-repo/revisions/latest)"
			rsync -av --progress ".patche-repo/revisions/$THISREVISION/snapshot/" "./"
			
			#For every file in the current directory
				#(not in ./.patche-repo or ./.patche-repo-temp), replace it
				#with the actual file data
			patcherecordunpacker() {
				#Record unpacker
				SHA=$("head -n 1 \"$1\"")
				if [ -f "./.patche-repo-temp/record-data-by-hash/$SHA" ]; then
					#If the sha512 contained within that file is the same as
						#one held locally on disk already, move the local file.
					mv -fv "./.patche-repo-temp/record-data-by-hash/$SHA" "$1"
				else
					#Else, download the necessary file from IA.
					IAURL=$("sed -n 2p \"$1\"")
					wget -O "./.patche-repo-temp/current.bin.pax.xz.gpg" "$IAURL"
					gpg --yes --batch --passphrase-file "./.patche-repo-temp/.pbz" "./.patche-repo-temp/current.bin.pax.xz.gpg"
					rm -v "./.patche-repo-temp/current.bin.pax.xz.gpg"
					unxz -v "./.patche-repo-temp/current.bin.pax.xz"
					rm -v "./.patche-repo-temp/current.bin.pax.xz"
					tar -x -v "./.patche-repo-temp/current.bin.pax"
					rm -v "./.patche-repo-temp/current.bin.pax"
					echo "Done extracting downloaded record; now patching payload into repository."
					mv -v "./.patche-repo-temp/current.bin" "$1"
				fi
			}
			export -f patcherecordunpacker
			find . -type f ! -path "./.patche-repo-temp/*" ! -path "./.patche-repo/*" -exec bash -c 'patcherecordunpacker "$0"' {} \;
			
			#Delete any remaining files known by their sha512s.
			echo "Done patching repository; cleaning up..."
			rm -rfv "./.patche-repo-temp/"
		else
			echo "You did not provide a revision URL to patch into this directory. Please provide the desired revision URL (it's probably a URL ending with \".patcherev5\") as the second argument to the patche command."
			echo "Aborting."
			exit 1
		fi
	fi
	if [ "$1" = "init" ]; then
		if [ "$2" != "" ]; then
			#Initialize repository
			echo "Initializing repository..."
			mkdir -p -v "./.patche-repo/logs"
			mkdir -p -v "./.patche-repo/config"
			if [ ! -d "./.patche-repo/revisions" ]; then
				echo "Creating revisions directory"
				mkdir "./.patche-repo/revisions"
			fi
			if [ ! -d "./.patche-repo/revisions/0" ]; then
				echo "Creating initial revision directory"
				mkdir "./.patche-repo/revisions/0"
			fi
			if [ ! -d "./.patche-repo/revisions/0/records-by-hash" ]; then
				echo "Creating hash directory"
				mkdir "./.patche-repo/revisions/0/records-by-hash"
			fi
			if [ ! -d "./.patche-repo/revisions/0/records-by-hash/uploaded" ]; then
				echo "Creating uploaded records directory"
				mkdir "./.patche-repo/revisions/0/records-by-hash/uploaded"
			fi
			echo -n "0" > "./.patche-repo/revisions/latest"
			echo "Set repository revision to 0."
			echo -n "$2" > "./.patche-repo/config/.pbz"
			echo "Set repository passphrase to second argument."
			echo -n "$NEWUUID" > "./.patche-repo/config/.uuid"
			echo "Set repository ID to $NEWUUID."
			echo "Done."
			exit 0;
		else
			echo "You did not provide a passphrase. Please provide your desired passphrase as the second argument to the patche command."
			echo "Aborting."
			exit 1;
		fi
	fi
	if [ "$1" = "commit" ]; then
		echo "Committing changes..."
		#Configure iu
		iu() {
			TIMEZONE=$(date +%z)
			IUIDENTIFIER=$(python -c 'import uuid; print str(uuid.uuid4())')-$(date +%Y.%m.%d.%H.%M.%S.%N)-$(xxd -pu <<< "$TIMEZONE")
			DIRECTORY=$(pwd)
			DIRECTORYHEX=$(xxd -pu <<< "$DIRECTORY")
			REPOID="$(cat ./.patche-repo/.uuid)"
			ia upload "$IUIDENTIFIER" --metadata="subject:Uploaded using iu for Patche $PATCHEVERSION; Patche repository $REPOID; $DIRECTORYHEX; 0D4F70AC-B0FD-11E5-9069-5A1D60F10656" "$@"
			UPLOADURLPREFIX='https://archive.org/download/'$IUIDENTIFIER
		}
		LASTREVISION="$(cat ./.patche-repo/revisions/latest)"
		THISREVISION=$((LASTREVISION+1))
		cp -Rv "./.patche-repo/revisions/$LASTREVISION/records-by-hash/" "./.patche-repo/revisions/$THISREVISION/records-by-hash/"

		#records-by-hash: ln -s each file to its sha256
		patchelink() { 
			#Records-by-hash linker
			#Link to records-by-hash
			SHA=$("shasum -a 512 \"$1\"")
			LINKTARGET="./.patche-repo/revisions/$THISREVISION/records-by-hash/$SHA"
			ln -sv "$1" "$LINKTARGET"
		}
		export -f patchelink
		find . -type f -exec bash -c 'patchelink "$0"' {} \;

		#snapshot: Clone the directory tree, copying any special files
		rsync -av --progress --exclude=.patche-repo/revisions/"$THISREVISION"/snapshot --no-i-r --include '*/' --exclude '*' . "./.patche-repo/revisions/$THISREVISION/snapshot"
		find . ! -type f -print0 | rsync -0 -av --progress --no-i-r --files-from=- "./.patche-repo/revisions/$THISREVISION/snapshot/"

		#uploaded: For each file present in records-by-hash and not in uploaded, upload it and add the URL to uploaded folder
		patcheupload() {
			#Record uploader
			SHA=$("shasum -a 512 \"$1\"")
			if ! [ -f "./.patche-repo/revisions/$THISREVISION/records-by-hash/uploaded/$SHA" ]; then
				#File hasn't already been uploaded, so upload it. $1 should be a symlink, but cp should follow it and work with the real file.
				cp "$1" "./.patche-repo/current.bin"
				#Compress and encrypt current.bin
				tar -cv --format pax -f "./.patche-repo/current.bin.pax" "./.patche-repo/current.bin"
				rm -v "./.patche-repo/current.bin"
				xz -k -C sha256 -9 -e -v "./.patche-repo/current.bin.pax"
				rm -v "./.patche-repo/current.bin.pax"
				gpg --yes -c --cipher-algo AES256 --batch --passphrase-file "./.patche-repo/.pbz" "./.patche-repo/config/current.bin.pax.xz"
				rm -v "./.patche-repo/current.bin.pax.xz"
				newuuid
				mv "./.patche-repo/current.bin.pax.xz.gpg" "./.patche-repo/$NEWUUID.patche5"
				iu "./.patche-repo/$NEWUUID"".patche5"
				UPLOADURL="$UPLOADURLPREFIX$NEWUUID"".patche5"
				printf -v RECORDSUFFIX '\n%s' "$UPLOADURL"
				RECORDDATA="$SHA$RECORDSUFFIX"
				echo "$RECORDDATA" > "./.patche-repo/revisions/$THISREVISION/snapshot/""$1"
				echo -n "$UPLOADURL" > "./.patche-repo/revisions/$THISREVISION/records-by-hash/uploaded/""$SHA"
				rm -v "./.patche-repo/$NEWUUID"".patche5"
			fi
		}
		export -f patcheupload
		find "./.patche-repo/revisions/$THISREVISION/records-by-hash/" -type f -exec bash -c 'patcheupload "$0"' {} \;

		#Compress and upload repository data
		tar -cv --format pax --exclude "./.patche-repo/snapshot.pax" -f "./.patche-repo/snapshot.pax" "./.patche-repo/"
		xz -k -C sha256 -9 -e -v "./.patche-repo/snapshot.pax"
		rm -v "./.patche-repo/snapshot.pax"
		gpg --yes -c --cipher-algo AES256 --batch --passphrase-file ./.patche-repo/.pbz "./.patche-repo/config/snapshot.pax.xz"
		rm -v "./.patche-repo/snapshot.pax.xz"
		newuuid
		mv "./.patche-repo/snapshot.pax.xz.gpg" "./.patche-repo/$NEWUUID.patcherev5"
		iu "./.patche-repo/$NEWUUID"".patcherev5"
		UPLOADURL="$UPLOADURLPREFIX$NEWUUID"".patcherev5"
		echo -n "$UPLOADURL" > "./.patche-repo/revisions/$THISREVISION/revision"
		rm -v "./.patche-repo/$NEWUUID"".patcherev5"

		#Commit is now complete and was successful, so clean up the previous revision data, and increment the latest revision ID.
		rm -rv "./.patche-repo/revisions/$LASTREVISION/records-by-hash/"
		rm -rv "./.patche-repo/revisions/$LASTREVISION/snapshot/"
		echo -n "$THISREVISION" > "./.patche-repo/revisions/latest"
	fi
	echo "No action or unknown action specified. Available actions are: patch, init, commit"
	echo "Aborting."
	
	DONETIME="$(date '+%Y.%m.%d-%H.%M.%S.%z')"
	echo "Done work at $DONETIME."

	: <<-'END'
	clone directory tree
	for each file, make a file in the cloned directory tree that contains its ia URL
	ln -s each file to its sha256
	Maintain a folder with all the sha256s that have been uled
	Any new ones, upload them
	and add them to that folder
	(as a sha256 containing the IA URL)
	Then pax.xz the folder of sha256s containg the IA url, and the folder of ln -ses
	and upload that.
	So, that file with the IA URLs by sha256 and the ln -ses are all that's needed to clone the repo
	I think that's pretty cool!
	When cloning, it'll 1) dl the pax.xz, 2) extract it, 3) donwnload any missing sha256s with the contents
	In the upload and download process, gpg the files.
	And pax.xz them
	in the other order
	1st step: If there aren't the necessary folder,s create them
	For the encryption, use a config file
	with the passphrase
	And that should be all that's needed to make this app work!
	I't'll need only the amuont of free disk space as the biggest file
	unlike Patche, which I'm using now, and needs 3x the free disk space of the whole repository
	END
}

echo "Are you sure you want to continue? This may destroy the directory structure and any data in $(pwd); back it up first! Make sure you have run ia configure before using Patche."

#based on http://unix.stackexchange.com/questions/134437/press-space-to-continue
read -n1 -r -p "Press space to continue if you're sure." key

if [ "$key" = ' ' ]; then
    # Space pressed
    patche "$@" 2>&1 | tee -a "$outfile"
else
    # Anything else pressed
    echo "Aborting."
    exit 0
fi

#eof
