#!/usr/bin/env bash
# Patche. Version 5.

# Needs at least as much disk space as the biggest file in the directory.

PATCHEVERSION="5"

#Script should run as root.
#Uncomment the next line and the eof for final version.
#exec sudo -s /bin/bash - << eof

#Exit if a command returns a nonzero value.
set -e;

#Set up logging
NOW="$(date '+%Y.%m.%d-%H.%M.%S.%z')"
outfile="./.patche-repo/logs/$NOW.log"

#Configure iu
iu() {
	TIMEZONE=$(date +%z)
	IUIDENTIFIER=$(python -c 'import uuid; print str(uuid.uuid4())')-$(date +%Y.%m.%d.%H.%M.%S.%N)-$(xxd -pu <<< "$TIMEZONE")
	DIRECTORY=$(pwd)
	DIRECTORYHEX=$(xxd -pu <<< "$DIRECTORY")
	ia upload "$IUIDENTIFIER" --metadata="subject:Uploaded using iu for Patche $PATCHEVERSION; $DIRECTORYHEX; 0D4F70AC-B0FD-11E5-9069-5A1D60F10656" "$@"
	UPLOADURLPREFIX='https://archive.org/download/'$IUIDENTIFIER
}

#UUID creator
newuuid() {
	NEWUUID=$(python -c 'import uuid; print str(uuid.uuid4())')
}

#Main function body
patche() {
	if [ "$1" = "patch" ]; then
		true
	fi
	if [ "$1" = "init" ]; then
		if [ "$2" != "" ]; then
			#Initialize repository
			if [ -d "./.patche-repo" ]; then
				echo "Repository does not exist; initializing"
				mkdir "./.patche-repo"
			else
				echo "Repository already exists! Aborting. Rename or remove ./.patche-repo to create a new repository."
				exit 1;
			fi
			if [ -d "./.patche-repo/logs" ]; then
				echo "Creating logs directory"
				mkdir "./.patche-repo/logs"
			fi
			if [ -d "./.patche-repo/config" ]; then
				echo "Creating configuration directory"
				mkdir "./.patche-repo/config"
			fi
			if [ -d "./.patche-repo/revisions" ]; then
				echo "Creating revisions directory"
				mkdir "./.patche-repo/revisions"
			fi
			if [ -d "./.patche-repo/revisions/0" ]; then
				echo "Creating initial revision directory"
				mkdir "./.patche-repo/revisions/0"
			fi
			if [ -d "./.patche-repo/revisions/0/records-by-hash" ]; then
				echo "Creating hash directory"
				mkdir "./.patche-repo/revisions/0/records-by-hash"
			fi
			if [ -d "./.patche-repo/revisions/0/records-by-hash/uploaded" ]; then
				echo "Creating uploaded records directory"
				mkdir "./.patche-repo/revisions/0/records-by-hash/uploaded"
			fi
			echo -n "$2" > "./.patche-repo/config/.pbz"
			echo "Set repository passphrase to second argument."
			echo -n "0" > "./.patche-repo/revisions/latest"
			echo "Set repository revision to 0."
			exit 0;
		else
			echo "You did not provide a passphrase. Please provide your desired passphrase as the second argument to the patche command."
			exit 1;
		fi
	fi
	if [ "$1" = "commit" ]; then
		LASTREVISION="$(cat ./.patche-repo/revisions/latest)"
		THISREVISION=$((LASTREVISION+1))
		cp -Rv "./.patche-repo/revisions/$LASTREVISION/records-by-hash/" "./.patche-repo/revisions/$THISREVISION/records-by-hash/"

		#records-by-hash: ln -s each file to its sha256
		patchelink() { 
			#Records-by-hash linker
			#Link to records-by-hash
			SHA=$("shasum -a 512 \"$1\"")
			LINKTARGET="./.patche-repo/revisions/$THISREVISION/records-by-hash/$SHA"
			ln -sv "$1" "$LINKTARGET"
		}
		export -f patchelink
		find . -type f -exec bash -c 'patchelink "$0"' {} \;

		#snapshot: Clone the directory tree, copying any special files
		rsync -av --progress --exclude=.patche-repo/revisions/"$THISREVISION"/snapshot --no-i-r --include '*/' --exclude '*' . "./.patche-repo/revisions/$THISREVISION/snapshot"
		find . ! -type f -print0 | rsync -0 -av --progress --no-i-r --files-from=- "./.patche-repo/revisions/$THISREVISION/snapshot/"

		#uploaded: For each file present in records-by-hash and not in uploaded, upload it and add the URL to uploaded folder
		patcheupload() {
			#Record uploader
			SHA=$("shasum -a 512 \"$1\"")
			if ! [ -f "./.patche-repo/revisions/$THISREVISION/records-by-hash/uploaded/$SHA" ]; then
				#File hasn't already been uploaded, so upload it. $1 should be a symlink, but cp should follow it and work with the real file.
				cp "$1" "./.patche-repo/current.bin"
				#Compress and encrypt current.bin
				tar -cv --format pax -f "./.patche-repo/current.bin.pax" "./.patche-repo/current.bin"
				rm -v "./.patche-repo/current.bin"
				xz -k -C sha256 -9 -e -v "./.patche-repo/current.bin.pax"
				rm -v "./.patche-repo/current.bin.pax"
				gpg --yes -c --cipher-algo AES256 --batch --passphrase-file "./.patche-repo/.pbz" "./.patche-repo/config/current.bin.pax.xz"
				rm -v "./.patche-repo/current.bin.pax.xz"
				newuuid
				mv "./.patche-repo/current.bin.pax.xz.gpg" "./.patche-repo/$NEWUUID.patche5"
				iu "./.patche-repo/$NEWUUID"".patche5"
				UPLOADURL="$UPLOADURLPREFIX$NEWUUID"".patche5"
				echo -n "$UPLOADURL" > "./.patche-repo/revisions/$THISREVISION/snapshot/""$1"
				echo -n "$UPLOADURL" > "./.patche-repo/revisions/$THISREVISION/records-by-hash/uploaded/""$SHA"
				rm -v "./.patche-repo/$NEWUUID"".patche5"
			fi
		}
		export -f patcheupload
		find "./.patche-repo/revisions/$THISREVISION/records-by-hash/" -type f -exec bash -c 'patcheupload "$0"' {} \;

		#Compress and upload repository data
		tar -cv --format pax --exclude "./.patche-repo/snapshot.pax" -f "./.patche-repo/snapshot.pax" "./.patche-repo/"
		xz -k -C sha256 -9 -e -v "./.patche-repo/snapshot.pax"
		rm -v "./.patche-repo/snapshot.pax"
		gpg --yes -c --cipher-algo AES256 --batch --passphrase-file ./.patche-repo/.pbz "./.patche-repo/config/snapshot.pax.xz"
		rm -v "./.patche-repo/snapshot.pax.xz"
		newuuid
		mv "./.patche-repo/snapshot.pax.xz.gpg" "./.patche-repo/$NEWUUID.patcherev5"
		iu "./.patche-repo/$NEWUUID"".patcherev5"
		UPLOADURL="$UPLOADURLPREFIX$NEWUUID"".patcherev5"
		echo -n "$UPLOADURL" > "./.patche-repo/revisions/$THISREVISION/revision"
		rm -v "./.patche-repo/$NEWUUID"".patcherev5"

		#Commit is now complete and was successful, so clean up the previous revision data, and increment the latest revision ID.
		rm -rv "./.patche-repo/revisions/$LASTREVISION/records-by-hash/"
		rm -rv "./.patche-repo/revisions/$LASTREVISION/snapshot/"
		echo -n "$THISREVISION" > "./.patche-repo/revisions/latest"
	fi
	echo "No action or unknown action specified. Available actions are: patch, init, commit"

	DONETIME="$(date '+%Y.%m.%d-%H.%M.%S.%z')"
	echo "Done work at $DONETIME."

	: <<-'END'
	clone directory tree
	for each file, make a file in the cloned directory tree that contains its ia URL
	ln -s each file to its sha256
	Maintain a folder with all the sha256s that have been uled
	Any new ones, upload them
	and add them to that folder
	(as a sha256 containing the IA URL)
	Then pax.xz the folder of sha256s containg the IA url, and the folder of ln -ses
	and upload that.
	So, that file with the IA URLs by sha256 and the ln -ses are all that's needed to clone the repo
	I think that's pretty cool!
	When cloning, it'll 1) dl the pax.xz, 2) extract it, 3) donwnload any missing sha256s with the contents
	In the upload and download process, gpg the files.
	And pax.xz them
	in the other order
	1st step: If there aren't the necessary folder,s create them
	For the encryption, use a config file
	with the passphrase
	And that should be all that's needed to make this app work!
	I't'll need only the amuont of free disk space as the biggest file
	unlike Patche, which I'm using now, and needs 3x the free disk space of the whole repository
	END
}

echo "Are you sure you want to continue? This may destroy the directory structure in $(pwd); back it up first! Make sure you have run ia configure before using Patche."

#based on http://unix.stackexchange.com/questions/134437/press-space-to-continue
read -n1 -r -p "Press space to continue if you're sure." key

if [ "$key" = ' ' ]; then
    # Space pressed
    patche "$@" 2>&1 | tee -a "$outfile"
else
    # Anything else pressed
    echo "Aborting."
    exit 0
fi

#eof




#!/bin/bash
#Patche. Version 4, 2015-April-05
#From http://serverfault.com/questions/137119/rsync-to-multiple-destinations-using-same-filelist I think the rsync in batch mode might need --delete, but I'm not sure.
NOW="`date '+%Y.%m.%d-%H.%M.%S.%z'`"
outfile="./.pch/logs/$NOW.log"
mkdir ./.pch
mkdir ./.pch/logs
echo -e "Beginning work at $NOW.\nWrap arguments in single quotation marks.\nSuggested to run this as root. Run ia configure first." 2>&1 | tee -a $outfile

if [ "$1" = "init" ]; then
	if [ "$2" != ""]; then
		echo "init" 2>&1 | tee -a $outfile
		PASSPHRASE="$2"
		REPOUUID="`uuidgen`"
		echo "$REPOUUID" > ./.pch/.uuid
		rm -rfv ./.pch/.pshadow/ 2>&1 | tee -a $outfile
		mkdir -v ./.pch 2>&1 | tee -a $outfile
		echo "$PASSPHRASE" > ./.pch/.pbz
		mkdir -v ./.pch/.ptub 2>&1 | tee -a $outfile
		mkdir -v ./.pch/.patches 2>&1 | tee -a $outfile
		mkdir -v ./.pch/.pshadow 2>&1 | tee -a $outfile
		rsync -av --progress --no-i-r --delete --write-batch="../$NOW.pinit" --exclude=".pch/.pshadow" . ./.pch/.pshadow/ 2>&1 | tee -a $outfile
		bzip2 -v "../$NOW.pinit" 2>&1 | tee -a $outfile
		mv -v "../$NOW.pinit.bz2" "../$NOW.pinit" 2>&1 | tee -a $outfile
		gpg --yes -c --cipher-algo AES256 --batch --passphrase-file ./.pch/.pbz "../$NOW.pinit" 2>&1 | tee -a $outfile
		mv -v "../$NOW.pinit.gpg" "../$NOW.pinite" 2>&1 | tee -a $outfile
		UUID="`uuidgen`"
		ia upload "$REPOUUID.$UUID" "../$NOW.pinite" --log --delete --checksum --metadata="title:Patche.$REPOUUID.$NOW.$UUID.pinite"
		echo -n "1" > ./.pch/.revision
		echo -n "$REPOUUID.$UUID $NOW" > "./.pch/.ptub/1. $NOW.pinitu"
		mv -v ./internetarchive.log "./.pch/logs/$NOW.ia.log" 2>&1 | tee -a $outfile
		rm -v "../$NOW.pinit" 2>&1 | tee -a $outfile
		mv -v "../$NOW.pinit.sh" "./.pch/.patches/" 2>&1 | tee -a $outfile
		fi

	else if [ "$1" = "clone" ]; then
		echo "clone" 2>&1 | tee -a $outfile
		IDENTIFIER="$2"
		FILENAME="$3"
		PASSPHRASE="$4"
		wget "https://archive.org/download/$2/$3.pinite" 2>&1 | tee -a $outfile
		mv -v "./$3.pinite" "./$3.pinit.gpg" 2>&1 | tee -a $outfile
		echo "$PASSPHRASE" > ./.pbz
		gpg --yes --batch --passphrase-file ./.pbz "./$3.pinit.gpg" 2>&1 | tee -a $outfile		
		#rm -v "./.pbz" 2>&1 | tee -a $outfile
		rm -v "./$3.pinit.gpg" 2>&1 | tee -a $outfile
		mv -v "./$3.pinit" "./$3.pinit.bz2" 2>&1 | tee -a $outfile
		bunzip2 "./$3.pinit.bz2" 2>&1 | tee -a $outfile
		rsync -av --progress --delete --read-batch="./$3.pinit" . 2>&1 | tee -a $outfile
		rm -v "./$3.pinit" 2>&1 | tee -a $outfile
		rsync -av --progress --no-i-r --delete --exclude=".pch/.pshadow" . ./.pch/.pshadow/ 2>&1 | tee -a $outfile


		else if [ "$1" = "commit" ]; then
			echo "commit" 2>&1 | tee -a $outfile
			LASTREVISION="`cat ./.pch/.revision`"
			#help from http://askubuntu.com/questions/385528/how-to-increment-a-variable-in-bash
			THISREVISION=$(($LASTREVISION+1))
			rsync -av --progress --no-i-r --delete --write-batch="../$NOW.patch" --exclude=".pch/.pshadow" . ./.pch/.pshadow/ 2>&1 | tee -a $outfile
			bzip2 -v "../$NOW.patch" 2>&1 | tee -a $outfile
			mv -v "../$NOW.patch.bz2" "../$NOW.patch" 2>&1 | tee -a $outfile
			gpg --yes -c --cipher-algo AES256 --batch --passphrase-file ./.pch/.pbz "../$NOW.patch" 2>&1 | tee -a $outfile
			mv -v "../$NOW.patch.gpg" "../$NOW.patche" 2>&1 | tee -a $outfile
			UUID="`uuidgen`"
			REPOUUID="`cat ./.pch/.uuid`"
			ia upload "$REPOUUID.$UUID" "../$NOW.patche" --log --delete --checksum --metadata="title:Patche.$REPOUUID.$NOW.$UUID.patche"
			echo -n "$REPOUUID.$UUID $NOW" > "./.pch/.ptub/$THISREVISION. $NOW.pchu"
			echo -n "$THISREVISION" > ./.pch/.revision
			mv -v ./internetarchive.log "./.pch/logs/$NOW.ia.log" 2>&1 | tee -a $outfile
			rm -v "../$NOW.patch" 2>&1 | tee -a $outfile
			mv -v "../$NOW.patch.sh" "./.pch/.patches/" 2>&1 | tee -a $outfile


			else if [ "$1" = "patch" ]; then
				echo "patch" 2>&1 | tee -a $outfile
				IDENTIFIER="$2"
				FILENAME="$3"
				PASSPHRASE="$4"
				wget "https://archive.org/download/$2/$3.patche" 2>&1 | tee -a $outfile
				mv -v "./$3.patche" "./$3.patch.gpg" 2>&1 | tee -a $outfile
				gpg --yes --batch --passphrase-file ./.pch/.pbz "./$3.patch.gpg" 2>&1 | tee -a $outfile		
				rm -v "./$3.patch.gpg" 2>&1 | tee -a $outfile
				mv -v "./$3.patch" "./$3.patch.bz2" 2>&1 | tee -a $outfile
				bunzip2 "./$3.patch.bz2" 2>&1 | tee -a $outfile
				rsync -av --progress --delete --no-i-r --read-batch="./$3.patch" . 2>&1 | tee -a $outfile
				rm -v "./$3.patch" 2>&1 | tee -a $outfile
				rsync -av --progress --no-i-r --delete --exclude=".pch/.pshadow" . ./.pch/.pshadow/ 2>&1 | tee -a $outfile
				else
					echo "Unknown action or no action specified. Available actions are: init, clone, commit, patch" 2>&1 | tee -a $outfile
				fi
			fi
		fi
	fi
@@ -180,7 +181,7 @@ 

DONETIME="`date '+%Y.%m.%d-%H.%M.%S.%z'`"
echo "Done work at $DONETIME." 2>&1 | tee -a $outfile