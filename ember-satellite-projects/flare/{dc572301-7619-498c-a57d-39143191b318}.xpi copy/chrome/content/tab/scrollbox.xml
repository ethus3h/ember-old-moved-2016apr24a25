<?xml version="1.0"?>

<bindings id="tabmix-arrowscrollboxBindings"
   xmlns="http://www.mozilla.org/xbl"
   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
   xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="tabmix-right-scrollBox"
           extends="chrome://global/content/bindings/scrollbox.xml#scrollbox-base">
    <content _side="right">
        <xul:toolbarbutton class="scrollbutton-up"
                           xbl:inherits="orient,disabled=scrolledtostart"
                           oncontextmenu="TabmixAllTabs.createScrollButtonTabsList(event, 'left');"
                           anonid="scrollbutton-up-right"
                           onclick="gBrowser.tabContainer.mTabstrip._distanceScroll(event);"
                           onmousedown="if (event.button == 0) gBrowser.tabContainer.mTabstrip._startScroll(-1);"
                           onmouseup="if (event.button == 0) gBrowser.tabContainer.mTabstrip._stopScroll();"
                           onmouseover="gBrowser.tabContainer.mTabstrip._continueScroll(-1);"
                           onmouseout="gBrowser.tabContainer.mTabstrip._pauseScroll();"/>
        <xul:toolbarbutton class="scrollbutton-down"
                           xbl:inherits="orient,disabled=scrolledtoend"
                           oncontextmenu="TabmixAllTabs.createScrollButtonTabsList(event, 'right');"
                           anonid="scrollbutton-down-right"
                           onclick="gBrowser.tabContainer.mTabstrip._distanceScroll(event);"
                           onmousedown="if (event.button == 0) gBrowser.tabContainer.mTabstrip._startScroll(1);"
                           onmouseup="if (event.button == 0) gBrowser.tabContainer.mTabstrip._stopScroll();"
                           onmouseover="gBrowser.tabContainer.mTabstrip._continueScroll(1);"
                           onmouseout="gBrowser.tabContainer.mTabstrip._pauseScroll();"/>
    </content>
    <implementation>
      <field name="_scrollButtonUp">
        document.getAnonymousElementByAttribute(this, "anonid", "scrollbutton-up-right");
      </field>

      <field name="_scrollButtonDown">
        document.getAnonymousElementByAttribute(this, "anonid", "scrollbutton-down-right");
      </field>

      <constructor>
        <![CDATA[
          let tabstrip = gBrowser.tabContainer.mTabstrip;
          tabstrip._scrollButtonDownRight = this._scrollButtonDown;
          tabstrip._scrollButtonUpRight = this._scrollButtonUp;
        ]]>
      </constructor>

      <method name="finishScroll">
        <parameter name="aEvent"/>
        <body><![CDATA[
          let tabBar = gBrowser.tabContainer;
          if (!tabBar.useTabmixDnD(aEvent))
            return;
          TMP_tabDNDObserver.clearDragmark();
          let index, target = aEvent.originalTarget.getAttribute("anonid");
          if (target == "scrollbutton-up-right")
            index = -1;
          else if (target == "scrollbutton-down-right")
            index = 1;
          if (index) {
            let tabstrip = gBrowser.tabContainer.mTabstrip;
            let amountToScroll, distanceToRow = tabstrip._distanceToRow(0);
            if (distanceToRow * index < 0)
              amountToScroll = tabstrip.singleRowHeight * index + distanceToRow;
            else
              amountToScroll = distanceToRow;
            tabstrip.scrollByPixels(amountToScroll);
          }
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="dragover"><![CDATA[
        let tabBar = gBrowser.tabContainer;
        if (tabBar.useTabmixDnD(event))
          TMP_tabDNDObserver.onDragOver(event);
      ]]></handler>

      <handler event="drop"><![CDATA[
        this.finishScroll(event);
      ]]></handler>

      <handler event="dragexit"><![CDATA[
        this.finishScroll(event);
      ]]></handler>
    </handlers>

  </binding>

  <binding id="tabmix-arrowscrollbox-clicktoscroll"
                  extends="chrome://global/content/bindings/scrollbox.xml#arrowscrollbox-clicktoscroll">
    <implementation>

      <!-- for Vertical Tabs extension -->
      <property name="_verticalTabs" readonly="true"
                onget="return this.orient == 'vertical';"/>

      <field name="blockUnderflow">false</field>
      <field name="blockOverflow">false</field>

      <field name="_scrollButtonUpLeft">
        document.getAnonymousElementByAttribute(this, "anonid", "scrollbutton-up");
      </field>

      <field name="_scrollButtonDownLeft">
        document.getAnonymousElementByAttribute(this, "anonid", "scrollbutton-down");
      </field>

      <field name="innerbox" readonly="true">
        document.getAnonymousElementByAttribute(this._scrollbox, "class", "box-inherit scrollbox-innerbox");
      </field>

      <!-- we replace tabbrowser.xml "tabbrowser-arrowscrollbox" binding with this one
           Override scrollbox.xml method, since our scrollbox's children are
           inherited from the binding parent -->
      <method name="_getScrollableElements">
        <body><![CDATA[
          return Array.filter(document.getBindingParent(this).childNodes,
                              this._canScrollToElement, this);
        ]]></body>
      </method>

      <method name="_canScrollToElement">
        <parameter name="tab"/>
        <body><![CDATA[
          return !tab.pinned && !tab.hidden;
        ]]></body>
      </method>

      <field name="_tabMarginLeft">null</field>
      <field name="_tabMarginRight">null</field>
      <method name="_calcTabMargins">
        <parameter name="aTab"/>
        <body><![CDATA[
          if (this._tabMarginLeft === null || this._tabMarginRight === null) {
            let tabMiddle = document.getAnonymousElementByAttribute(aTab, "class", "tab-background-middle");
            let tabMiddleStyle = window.getComputedStyle(tabMiddle, null);
            this._tabMarginLeft = parseFloat(tabMiddleStyle.marginLeft);
            this._tabMarginRight = parseFloat(tabMiddleStyle.marginRight);
          }
        ]]></body>
      </method>

      <method name="_adjustElementStartAndEnd">
        <parameter name="aTab"/>
        <parameter name="tabStart"/>
        <parameter name="tabEnd"/>
        <body><![CDATA[
          if (this.isMultiRow)
            return [tabStart, tabEnd];

          this._calcTabMargins(aTab);
          if (this._tabMarginLeft < 0) {
            tabStart = tabStart + this._tabMarginLeft;
          }
          if (this._tabMarginRight < 0) {
            tabEnd = tabEnd - this._tabMarginRight;
          }
          return [tabStart, tabEnd];
        ]]></body>
      </method>

      <constructor>
        <![CDATA[
          if (this.tabmix_inited)
            return;

          this.tabmix_inited = true;

          this.offsetAmountToScroll = Tabmix.prefs.getBoolPref("offsetAmountToScroll");
          this.offsetRatio = Tabmix.tabsUtils.closeButtonsEnabled ? 0.70 : 0.50;
          this.minOffset = TabmixSvc.australis ? 25 : 50;
          Tabmix.changeCode(this, "scrollbox.ensureElementIsVisible")._replace(
            'var amountToScroll',
            '$&, offset = true'
          )._replace(
            'STOP_DISTANCE = 15;',
            'STOP_DISTANCE = this.isMultiRow ? 3 : 15;'
          )._replace(
            'amountToScroll = this._isScrolling * STOP_DISTANCE;',
            '{$& \
             offset = false;}'
          )._replace(
            'this._stopSmoothScroll();',
            '$& \
             if (offset) {\
               amountToScroll += this.getOffsetAmountToScroll(element, amountToScroll);}'
          ).toCode();

          Tabmix.changeCode(this, "scrollbox._distanceScroll")._replace(
            '{',
            '{ if (aEvent.button && aEvent.button == 2) return;'
          ).toCode();

          Tabmix.changeCode(this, "scrollbox._smoothScrollByPixels")._replace(
            '{',
            '$& \
             amountToScroll = this._distanceToRow(amountToScroll);'
          ).toCode();

          // we divide scrollDelta by the ratio between tab width and tab height
          Tabmix.changeCode(this._arrowScrollAnim, "scrollbox._arrowScrollAnim.sample")._replace(
            '0.5 * timePassed * scrollIndex',
            'this.scrollbox.isMultiRow ? $& / this.scrollbox._verticalAnimation : $&'
          ).toCode();

          // the ratio between tab width and tab height is approximately 6
          // we multiply here the distance to get same animation effect.
          Tabmix.changeCode(this._scrollAnim, "scrollbox._scrollAnim.start")._replace(
            'Math.abs(distance)',
            'Math.abs(distance * (this.scrollbox.isMultiRow ? this.scrollbox._verticalAnimation : 1))'
          ).toCode();

          if (Tabmix.isVersion(320)) {
            Tabmix.changeCode(this, "scrollbox._updateScrollButtonsDisabledState")._replace(
              // when theme or extension add negative margin-bottom to the tab or
              // tab content the scrollHeight can be larger than the actual
              // inner-box height
              'this.scrollSize',
              '(this.orient == "vertical" && this.isMultiRow ? this.innerbox.getBoundingClientRect().height : $&)'
            )._replace(
              /(\})(\)?)$/,
              '          let box = document.getElementById("tabmixScrollBox");\n' +
              '          Tabmix.setItem(box, "scrolledtoend", scrolledToEnd || null);\n' +
              '          Tabmix.setItem(box, "scrolledtostart", scrolledToStart || null);\n' +
              '$1$2'
            ).toCode();
          }

          this._scrollButtonUpLeft.addEventListener("contextmenu", this._createScrollButtonContextMenu, true);
          this._scrollButtonDownLeft.addEventListener("contextmenu", this._createScrollButtonContextMenu, true);

          Services.prefs.addObserver("toolkit.scrollbox.", this.tabmixPrefObserver, false);
          this.firstVisible =  {tab: null, x: 0, y: 0};
        ]]>
      </constructor>

      <destructor>
        <![CDATA[
          this._scrollButtonUpLeft.removeEventListener("oncontextmenu", this._createScrollButtonContextMenu, true);
          this._scrollButtonDownLeft.removeEventListener("oncontextmenu", this._createScrollButtonContextMenu, true);

          Services.prefs.removeObserver("toolkit.scrollbox.", this.tabmixPrefObserver);
        ]]>
      </destructor>

      <method name="_createScrollButtonContextMenu">
        <parameter name="aEvent"/>
        <body><![CDATA[
          let side = aEvent.target.className == "scrollbutton-up" ? "left" : "right";
          TabmixAllTabs.createScrollButtonTabsList(aEvent, side);
        ]]></body>
      </method>

      <field name="tabmixPrefObserver"><![CDATA[({
        scrollbox: this,
        observe: function (subject, topic, data) {
          switch (data) {
            case "toolkit.scrollbox.clickToScroll.scrollDelay":
              this.scrollbox._scrollDelay = Services.prefs.getIntPref(data);
              break;
            case "toolkit.scrollbox.smoothScroll":
              this.scrollbox.smoothScroll = Services.prefs.getBoolPref(data);
              break;
          }
        }
      });]]></field>

      <!-- replace the original method -->
      <method name="scrollByPixels">
        <parameter name="px"/>
        <parameter name="aSmoothScroll"/>
        <body><![CDATA[
          let newPx = (this._isScrolling || aSmoothScroll) ? px : this._distanceToRow(px);
          this.scrollPosition += newPx;
        ]]></body>
      </method>

      <method name="getOffsetAmountToScroll">
        <parameter name="element"/>
        <parameter name="amountToScroll"/>
        <body><![CDATA[
          var offset = 0, isScrollingLeft = amountToScroll > 0;
          if (amountToScroll != 0 && this.offsetAmountToScroll &&
              !this.isMultiRow) {
            let tab;
            if (isScrollingLeft)
              tab = Tabmix.visibleTabs.next(element);
            else
              tab = Tabmix.visibleTabs.previous(element);
            if (tab) {
              offset = Math.min(this.minOffset, this.offsetRatio * tab.getBoundingClientRect().width);
              if (!isScrollingLeft)
                offset = Math.min(this.scrollPosition, offset);
            }
          }
          return isScrollingLeft ? offset : -offset;
        ]]></body>
      </method>

      <method name="_distanceToRow">
        <parameter name="amountToScroll"/>
        <body><![CDATA[
          if (!this.isMultiRow)
            return amountToScroll;
          let rowHeight = this.singleRowHeight;
          let position = this.scrollPosition;
          return Math.round((amountToScroll + position) / rowHeight) * rowHeight - position;
        ]]></body>
      </method>

      <field name="_verticalAnimation">4</field>
      <field name="_smoothVerticalScroll">6</field>
      <field name="_singleRowHeight">null</field>

      <property name="isMultiRow" readonly="true">
        <getter><![CDATA[
          return this.getAttribute("flowing") == "multibar";
        ]]></getter>
      </property>

      <property name="singleRowHeight" readonly="true">
        <getter><![CDATA[
          if (this._singleRowHeight)
            return this._singleRowHeight;

          if (TabmixTabbar.visibleRows > 1) {
            this._singleRowHeight = TabmixTabbar.singleRowHeight;
            this._smoothVerticalScroll = Math.round(this._singleRowHeight / 4);
            return this._singleRowHeight;
          }

          // still in one row
          var tabs = document.getBindingParent(this);
          let height = tabs.selectedItem.boxObject.height;
          if (height)
            return height;

          // if selectedItem don't have height find other tab that does
          for (let i = 0; i < tabs.childNodes.length; i++) {
             let tab = tabs.childNodes[i];
             let height = tab.boxObject.height;
             if (height)
               return height;
          }

          return this._scrollbox.boxObject.height;
        ]]></getter>
      </property>

      <method name="_enterVerticalMode">
        <parameter name="blockUnderflow"/>
        <body><![CDATA[
          // when widthFitTitle is false we enter vertical mode only after we are in overflow
          // if first or last tab is unvisible enter vertical mode
          // we can get here from new tabs, window resize tabs change width
          // so we call this function after 3 events TabOpen, overflow and scroll
          this.__needToSetVerticalOrient = false;
          if (this.orient == "vertical")
            return;

          Tabmix.tabsUtils.adjustNewtabButtonvisibility();
          let tabs = this._getScrollableElements();
          if (!tabs.length)
            return;
          let isFirstTabVisible = Tabmix.tabsUtils.isElementVisible(tabs[0]);
          let isLastTabVisible = Tabmix.tabsUtils.isElementVisible(tabs[tabs.length-1]);
          if (!isFirstTabVisible || !isLastTabVisible) {
            // show Newtabbutton for the first time
            // for the case last tab in row fill the all strip and the button
            // is on the next row
            Tabmix.tabsUtils.disAllowNewtabbutton = false;
            this.orient = "vertical";
            let tabBar = document.getBindingParent(this);
            Tabmix.setItem(tabBar, "multibar", true);
            Tabmix.setItem("TabsToolbar", "multibar", true);
            if (Tabmix.tabsUtils.updateVerticalTabStrip() == null)
              TabmixTabbar._failedToEnterVerticalMode = true;
            if (blockUnderflow && this.orient == "vertical")
              this.blockUnderflow = true;
            this.updateOverflow(Tabmix.tabsUtils.overflow);
          }
        ]]></body>
      </method>

      <field name="firstVisibleRow">null</field>
      <method name="setFirstTabInRow">
        <parameter name="scroll"/>
        <body><![CDATA[
          let firstVisibleRow = Math.round(this.scrollPosition / this.singleRowHeight) + 1;
          if (scroll) {
            if (this.firstVisibleRow == firstVisibleRow)
              return;
          }
          else if (this.firstVisible.tab) {
            let rect = this.firstVisible.tab.getBoundingClientRect();
            if (this.firstVisible.x == rect.left && this.firstVisible.y == rect.top)
              return;
          }

          this.firstVisibleRow = firstVisibleRow;

///XXX check if we can set the margin with animation when we scroll
          let end = Tabmix.ltr ? "right": "left";
          let containerEnd = this.scrollClientRect[end];
          let topY = Tabmix.tabsUtils.topTabY;
          let tabs = this._getScrollableElements();
          let index, current = 0;
          for (let i = 0; i < tabs.length; i++) {
            let tab = tabs[i];
            if (tab.closing) {
              tab.removeAttribute("tabmix-firstTabInRow");
              continue;
            }
            let row = Tabmix.tabsUtils.getTabRowNumber(tab, topY);
            if (row > current) {
              current = row;
              if (!tab.hasAttribute("tabmix-firstTabInRow"))
                tab.setAttribute("tabmix-firstTabInRow", true);
              else if (i > 0) {
                // remove the margin when the tab have place in the previous row
                let tabEnd = tabs[i-1].getBoundingClientRect()[end] + (Tabmix.ltr ? tab.getBoundingClientRect().width : 0);
                if (!Tabmix.compare(tabEnd, containerEnd, Tabmix.rtl)) {
                  tab.removeAttribute("tabmix-firstTabInRow");
                  continue;
                }
              }
              if (row == firstVisibleRow) {
                let rect = tab.getBoundingClientRect();
                this.firstVisible = {tab: tab, x: rect.left, y: rect.top};
                index = ++i;
                break;
              }
            }
            else if (tab.hasAttribute("tabmix-firstTabInRow"))
              tab.removeAttribute("tabmix-firstTabInRow");
          }
          for (let i = index; i < tabs.length; i++) {
            let tab = tabs[i];
            if (tab.hasAttribute("tabmix-firstTabInRow"))
              tab.removeAttribute("tabmix-firstTabInRow");
          }

          // if a smoothScroll is in progress call ensureElementIsVisible again
          // the amountToScroll changed when we changed firstTabInRow
          if (this._scrollTarget)
            this.ensureElementIsVisible(this._scrollTarget, true);
        ]]></body>
      </method>

      <field name="firstTabInRowMargin">0</field>
      <method name="resetFirstTabInRow">
        <body><![CDATA[
          if (this.firstTabInRowMargin == 0)
            return;
          this.firstTabInRowMargin = 0;
          // getElementsByAttribute return a live nodList
          // each time we remove the attribute we remove node from the list
          let tabBar = document.getBindingParent(this);
          let tabs = tabBar.getElementsByAttribute("tabmix-firstTabInRow" , "*");
          for (let i = 0, num = tabs.length; i < num; i++) {
            tabs[0].removeAttribute("tabmix-firstTabInRow");
          }
          this.firstVisible =  {tab: null, x: 0, y: 0};
        ]]></body>
      </method>

      <method name="updateOverflow">
        <parameter name="overflow"/>
        <body><![CDATA[
          // we get here after we update overflow from updateVerticalTabStrip
          if (this.orient == "horizontal" ||
              this.hasAttribute("notoverflowing") == !overflow)
            return;

          Tabmix.setItem(this, "notoverflowing", !overflow || null);

          try {
            // See bug 341047 and comments in overflow handler as to why
            // try..catch is needed here
            this._updateScrollButtonsDisabledState();

            if (!overflow) {
              let childNodes = this._getScrollableElements();
              if (childNodes && childNodes.length)
                this.ensureElementIsVisible(childNodes[0], false);
            }
          }
          catch(e) {
            Tabmix.setItem(this, "notoverflowing", overflow || null);
          }
        ]]></body>
      </method>

    </implementation>

    <handlers>
      <handler event="underflow" phase="capturing"><![CDATA[
        // filter underflow events which were dispatched on nested scrollboxes
        if (event.originalTarget != this._scrollbox)
          return;

        if (this.orient == "vertical") {
          // vertical scrollbox - Ignore horizontal events
          if (event.detail == 1 || this.blockUnderflow) {
            this.blockUnderflow = false;
            return;
          }
        }
        else {
          // horizontal scrollbox - Ignore vertical events
          if (event.detail == 0)
            return;
        }

        var tabs = document.getBindingParent(this);
        if (tabs.hasAttribute("multibar") && Tabmix.tabsUtils.overflow) {
          //XXX don't do anything on Linux when hovering last tab and
          // we show close button on tab on hover
          if (!TabmixSvc.isLinux || TabmixTabbar.visibleRows == 1 ||
              (!Tabmix.visibleTabs.last.hasAttribute("showbutton") &&
               !Tabmix.visibleTabs.last.hasAttribute("showbutton_removed")))
            Tabmix.tabsUtils.updateVerticalTabStrip();
        }
        else
          Tabmix.tabsUtils.overflow = false;
      ]]></handler>

      <handler event="overflow"><![CDATA[
        // filter overflow events which were dispatched on nested scrollboxes
        if (event.originalTarget != this._scrollbox)
          return;

        var tabs = document.getBindingParent(this);
        if (this.orient == "vertical") {
          // vertical scrollbox - Ignore horizontal events
          if (event.detail == 1 || this.blockOverflow) {
            this.blockOverflow = false;
            return;
          }
        }
        else {
          // horizontal scrollbox - Ignore vertical events
          if (event.detail == 0)
            return;
          if (this.isMultiRow && !this._enterVerticalModeTimeout) {
            this.__needToSetVerticalOrient = true;
            // when widthFitTitle is false we enter vertical mode only after we are in overflow
            // if first or last tab is unvisible enter vertical mode
            let self = this;
            this._enterVerticalModeTimeout = setTimeout(function() {
              self._enterVerticalModeTimeout = null;
              self._enterVerticalMode(true);
            }, 25);
            return;
          }
        }

        if (this.isMultiRow) {
          //XXX don't do anything on Linux when hovering last tab and
          // we show close button on tab on hover
          if (!TabmixSvc.isLinux || TabmixTabbar.visibleRows == 1 ||
              !Tabmix.visibleTabs.last.hasAttribute("showbutton"))
            Tabmix.tabsUtils.updateVerticalTabStrip();
        }
        else
          Tabmix.tabsUtils.overflow = true;
      ]]></handler>

      <handler event="scroll"><![CDATA[
        if (this.__needToSetVerticalOrient)
          this._enterVerticalMode();

        let tabBar = document.getBindingParent(this);
        tabBar._unlockTabSizing();

        if (this.isMultiRow && tabBar.firstChild.pinned)
          this.setFirstTabInRow(true);
      ]]></handler>

    </handlers>
  </binding>

  <!-- for tabbar on the bottom of the screen -->
  <binding id="toolbar"
           extends="chrome://global/content/bindings/toolbar.xml#toolbar">
    <content>
        <xul:hbox flex="1"
                  xbl:inherits="orient,width"
                  anonid="toolbar-innerbox"
                  class="tabmixplus-toolbar-inner-box">
          <xbl:children/>
        </xul:hbox>
    </content>
    <implementation implements="nsIDOMEventListener">
      <constructor>
        <![CDATA[
          //XXX we don't check for aEvent.target != window to catch changs in browser-bottombox
          // try to improve it
          window.addEventListener("resize", this.tabmixHandleEvent, false);
          this.updatePosition();
        ]]>
      </constructor>

      <destructor>
        <![CDATA[
          window.removeEventListener("resize", this.tabmixHandleEvent, false);
        ]]>
      </destructor>

      <field name="tabmixToolbarInnerBox" readonly="true">
        document.getAnonymousElementByAttribute(this, 'anonid', 'toolbar-innerbox');
      </field>

      <method name="updatePosition">
        <body><![CDATA[
          let updateFullScreen, tabBar = gBrowser.tabContainer;
          Tabmix.setItem(tabBar.mTabstrip, "flowing", TabmixTabbar.flowing);
          Tabmix.tabsUtils.tabstripInnerbox = document.getAnonymousElementByAttribute(
            tabBar.mTabstrip._scrollbox, "class", "box-inherit scrollbox-innerbox");
          let bottomToolbox = document.getElementById("tabmix-bottom-toolbox");
          if (!bottomToolbox) {
            bottomToolbox = document.createElement("toolbox");
            bottomToolbox.setAttribute("id", "tabmix-bottom-toolbox");
            bottomToolbox.collapsed = !gBrowser.tabContainer.visible;
            if (navigator.oscpu.startsWith("Windows NT 6.1"))
              bottomToolbox.setAttribute("tabmix_aero", true);
            // if we decide to move this box into browser-bottombox
            // remember to fix background css rules for all platform
            let referenceNode = document.getElementById("ctraddon_addon-bar");
            // referenceNode = referenceNode ? referenceNode.nextSibling :
              // document.getElementById("browser-bottombox");
            referenceNode.parentNode.insertAfter(bottomToolbox, referenceNode);
            updateFullScreen = window.fullScreen;
          }
          if (tabBar.visible)
            gTMPprefObserver.updateTabbarBottomPosition();
          else {
            // the tabbar is hidden on startup
            let height = tabBar.mTabstrip.scrollClientRect.height;
            bottomToolbox.style.setProperty("height", height + "px", "important");
            let tabsToolbar = document.getElementById("TabsToolbar");
            tabsToolbar.style.setProperty("top", screen.availHeight + "px", "important");
            tabsToolbar.setAttribute("width", screen.availWidth);
          }
          // force TabmixTabbar.setHeight to set tabbar height
          TabmixTabbar.visibleRows = 1;
          if (updateFullScreen) {
            TMP_eventListener.toggleTabbarVisibility(false);
            TabmixTabbar.updateSettings(false);
          }
        ]]></body>
      </method>

      <method name="tabmixHandleEvent">
        <parameter name="aEvent"/>
        <body><![CDATA[
          switch (aEvent.type) {
            case "resize":
              gTMPprefObserver.updateTabbarBottomPosition(aEvent);
              break;
          }
        ]]></body>
      </method>

    </implementation>
  </binding>

</bindings>
